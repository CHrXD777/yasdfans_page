[{"id":0,"href":"/ravsoch/posts/","title":"posts","section":"欢迎","content":""},{"id":1,"href":"/ravsoch/posts/%E8%BF%9C%E7%A8%8B%E4%B8%B2%E6%B5%81/","title":"sunshine + moonlight + 皎月连","section":"posts","content":"\rsunshine(PC)\r#\r安装： scoop install sunshine 基础设置：\n创建账号并登录 General -\u0026gt; 语言改成中文 Network -\u0026gt; UPnP.启用、IP地址组.IPV4_IPV6 高级设置： 通过安装目录中的tools/下的控制台应用获取信息，然后设置sunshine捕获的设备，默认情况下是够用的 moonlight(android)\r#\r安装： google play 下载安装moonlight 基础设置：\n选择你想要的分辨率 码率会自动计算 其他的看得懂就选一选看不懂默认就行 进行串流\r#\rmoonlight点击右上角加号，输入ip地址，如果是本地wifi环境，通过控制台命令ipconfig查看PC端的ip(不会就查)，填入并确定，然后在sunshine中发送号码即可完成串流。\n皎月连\r#\r如果是外网环境，通过皎月连获取ip地址，流程相同，\r详细教程\n如果你想熄屏游玩\r#\r原文链接\n无非五种方案：\n专业级显卡直接支持添加 EDID Profile 来虚拟显示器（NVIDIA GRID） 用 HDMI 诱骗器（假负载），淘宝十五一个 SplashTop、VNC 的虚拟显示器（不清楚具体实现） Windows 10 1607 之前的系统可以通过强制 VGA 输出（如图） 方案一富哥方案、方案二穷佬方案，方案三不知道、方案四不知道、文章介绍的方案五因为是通过集显输出的不好用，我的方案是副屏对墙，sunshine获取副屏内容\n如果你的游戏不支持手柄(或支持不好)\r#\r可以使用 JoytoKey 映射手柄按键到键盘, 下载地址\n"},{"id":2,"href":"/ravsoch/posts/Making-a-smiley-in-ShaderToy/","title":"在Shadertoy中制作笑脸[The Art of Code(5)]","section":"posts","content":" 基础框架\r#\r对坐标轴基操一下\n然后逐一完成各个部分代码\n基础框架 #define S(a, b, t) smoothstep(a, b, t) #define sat(x) clamp(x, 0., 1.) vec4 Brow(vec2 uv) { vec4 col = vec4(0.); return col; } vec4 Eye(vec2 uv) { vec4 col = vec4(0.); return col; } vec4 Mouth(vec2 uv) { vec4 col = vec4(0.); return col; } vec4 Head(vec2 uv) { vec4 col = vec4(0.); return col; } vec4 Smiley(vec2 uv) { vec4 col = vec4(0.); return col; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= .5; uv.x *= iResolution.x/iResolution.y; // Output to screen fragColor = Smiley(uv); } 辅助函数\r#\r//01映射 float remap01(float a, float b, float t) { return sat((t-a)/(b-a)); } //重映射 float remap(float a, float b, float c, float d, float t) { return sat((t-a)/(b-a)*(d-c) + c); } //二维重映射 vec2 inBox(vec2 uv, vec4 rect) { return (uv-rect.xy)/(rect.zw-rect.xy); } 头\r#\rSmiley(): vec4 head = Head(uv); col = mix(col, head, head.a);//以head透明度为参数混合col和head的颜色 vec4 Head(vec2 uv) { vec4 col = vec4(1.); float d = length(uv); col.a = S(.5, .48, d);//透明的通道用圆形距离场框个半径为.5的圆 //两种颜色中心渐变 vec3 aCol = mix(vec3(1., .2, .2), vec3(1.), -d); vec3 bCol = mix(vec3(1., 1., 0.), vec3(1.), d); col.rgb = mix(aCol, bCol, .4);//调整到合适的渐变参数 //阴影 float edgeShade = remap01(.35, .5, d);//调整渐变范围 edgeShade *= edgeShade;//x^2曲线能更好的模拟阴影 col.rgb *= 1. - edgeShade*.5;//调整曲线强度和方向并作用于col.rgb //高光 float highlight = S(.41, .405, d);//范围 highlight *= remap(.41, -.1, .65, 0., uv.y);//调整渐变 ////眼眶 highlight *= S(.18, .19, length(uv-vec2(.20, -.0)));//范围和位置 col.rgb = mix(col.rgb, vec3(1.), highlight);//混合颜色到col.rgb中 //大脸盘子外轮廓 col.rgb = mix(col.rgb, vec3(.8, .1, .1), S(.45, .48, d));//直接在外轮廓区域混想要的颜色 //腮红 d = length(uv - vec2(.25, -.08));//位置 float cheek = S(.2, .01, d)*.4;//范围和强度 cheek *= S(.16, .15, d);//将腮红边缘稍微卡一下，不是完全淡出 col.rgb = mix(col.rgb, vec3(.8, .1, .1), cheek);//把腮红颜色在腮红范围里与col.rgb混合 return col; } 眼睛\r#\r加一个二维重映射函数，可以将坐标重映射到想要的区域，原理和一维的重映射函数相同\nvec2 inBox(vec2 uv, vec4 rect) { return (uv-rect.xy)/(rect.zw-rect.xy); } 完善代码\nSmiley(): vec4 eye = Eye(inBox(uv, vec4(.03, -.15, .35, .17)));//将坐标系重映射到给定的矩形中再传入Eye() col = mix(col, eye, eye.a); vec4 Eye(vec2 uv) { uv -= .5;//因为重映射了uv，原点在给定矩形左下角，所以重新中心化 float d = length(uv); //眼球 vec4 irisCol = vec4(.2, .2, .5, 1.);//设定虹膜颜色 vec4 col = mix(vec4(1.), vec4(.8, .2, .2, 1.), S(.3, .7, d));//眼白部分稍微来点渐变，更好看 col.a = S(.5, .48, d);//设定透明度范围 //虹膜边框 col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); //虹膜 irisCol.rgb *= 1. + S(.3, .05, d); col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d)); //瞳孔 col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d)); //高光 //float highlight = S(.1, .09, length(uv-vec2(-.15,.15)));//因为是愤怒的表情，所以我不想要上方的高光，看着凶一点 float highlight = S(.07, .05, length(uv-vec2(.08,-.08))); col.rgb = mix(col.rgb, vec3(1.), highlight); //鼻梁 col.rgb *= 1. - S(.45, .5, d)*.5 * sat(-uv.y-uv.x);//sat返回0--1之间的数，对uv来说就是只返回正数，因为加了个负号所以取反 return col; } 嘴\r#\rSmiley(): vec4 mouth = Mouth(inBox(uv, vec4(-.2, -.35, .2, -.05))); col = mix(col, mouth, mouth.a); vec4 Mouth(vec2 uv) { //中心化和调整嘴巴的形状 uv -= .5; uv.y *= 3.; uv.y += uv.x*uv.x*3.;//上一个教程有提到uv.y是怎么被影响的 float d = length(uv); vec4 col = vec4(0.5, .18, .05, 1.); col.a = S(.5, .48, d);//嘴透明度范围 float td = length(uv-vec2(0., .4));//牙齿位置 vec3 toothCol = vec3(1.) * S(.6, .35, d);//牙齿颜色 col.rgb = mix(col.rgb, toothCol, S(.3, .28, td));//应用牙齿 //下面这部分是笑脸的舌头代码，但我做的事怒脸，就没用上来 //原理都差不多，设定位置、范围、颜色然后混合 //td = length(uv+vec2(0., .5)); //col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.4, .2, td)); //col.a = S(.5, .48, d); return col; } 眉毛\r#\rSmiley(): vec4 brow = Brow(inBox(uv, vec4(.0, .2, .35, .43))); col = mix(col, brow, brow.a); vec4 Brow(vec2 uv) { //调整眉毛位置和变形 float y = uv.y; uv.y -= uv.x*.7-1.1; uv -= .5; vec4 col = vec4(0.); float blur = .1; //眉毛，用两个“圆”相减得到 float d1 = length(uv); float s1 = S(.45, .45-blur, d1); float d2 = length(uv-vec2(-.05, -.35)*.7); float s2 = S(.5, .5-blur, d2); float browMask = sat(s1-s2); //提亮一部分眉毛，更立体好看一些 float colMask = remap01(.2, -.3, y)*.3; colMask *= S(.6, .9, browMask); vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); //眉毛的阴影，微调了位置和虚化程度 uv.y += .1; blur += .1; d1 = length(uv); s1 = S(.45, .45-blur, d1); d2 = length(uv-vec2(-.05, -.35)*.7); s2 = S(.5, .5-blur, d2); float shadowMask = sat(s1-s2); col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5); col = mix(col, browCol, S(.2, .4, browMask)); return col; } 截图\r#\r笑脸\n愤怒\n完整代码\r#\r笑·完整代码\r#\r#define S(a, b, t) smoothstep(a, b, t) #define sat(x) clamp(x, 0., 1.) float remap01(float a, float b, float t) { return sat((t-a)/(b-a));//防止t不在ab范围内 } float remap(float a, float b, float c, float d, float t) { return sat(c + (d-c)*(t-a)/(b-a)); } //二维remap01 vec2 within(vec2 uv, vec4 rect) { return (uv-rect.xy)/(rect.zw-rect.xy); //如果uv坐标在rect区域左下角,则输出uv为(0., 0.),右上角输出uv为(1., 1.) //和一维的一个道理 } vec4 Brow(vec2 uv) { float y = uv.y; uv.y += uv.x*.5-.1; //uv.x -= .1; uv -= .5; vec4 col = vec4(0.); float blur = .1; float d1 = length(uv); float s1 = S(.45, .45-blur, d1); float d2 = length(uv-vec2(.1, -.2)*.7); float s2 = S(.5, .5-blur, d2); float browMask = sat(s1-s2); float colMask = remap01(.7, .8, y)*.75; colMask *= S(.6, .9, browMask); vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); uv.y += .15; blur += .1; d1 = length(uv); s1 = S(.45, .45-blur, d1); d2 = length(uv-vec2(.1, -.2)*.7); s2 = S(.5, .5-blur, d2); float shadowMask = sat(s1-s2); col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5); col = mix(col, browCol, S(.2, .4, browMask)); return col; } vec4 Eye(vec2 uv) { uv -= .5; float d = length(uv); vec4 irisCol = vec4(.3, .4, .1, 1.); vec4 col = mix(vec4(1.), irisCol, S(.1, .7, d)*.5); col.rgb *= 1. - S(.45, .5, d)*.5 * sat(-uv.y-uv.x); col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); irisCol.rgb *= 1. + S(.3, .05, d); col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d)); col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d)); float highlight = S(.07, .05, length(uv-vec2(.08,-.08))); highlight += S(.1, .09, length(uv-vec2(-.15,.15))); col.rgb = mix(col.rgb, vec3(1.),highlight); col.a = S(.5, .48, d); return col; } vec4 Mouth(vec2 uv) { uv -= .5; vec4 col = vec4(0.5, .18, .05, 1.); uv.y *= 1.5; uv.y -= uv.x*uv.x*2.; float d = length(uv); float td = length(uv-vec2(0., .6)); vec3 toothCol = vec3(1.) * S(.6, .35, d); col.rgb = mix(col.rgb, toothCol, S(.4, .37, td)); td = length(uv+vec2(0., .5)); col.rgb = mix(col.rgb, vec3(1., .5, .5), S(.4, .2, td)); col.a = S(.5, .48, d); return col; } vec4 Head(vec2 uv) { vec4 col = vec4(.5, .4, .8, 1.); float d = length(uv); col.a = S(.5, .49, d); float edgeShade = remap01(.35, .5, d); edgeShade *= edgeShade; col.rgb *= 1.- edgeShade*.5; col.rgb = mix(col.rgb, vec3(.4, .3, .8), S(.47, .48, d)); float highlight = S(.41, .405, d); highlight *= remap(.41, -.1, .75, 0., uv.y); highlight *= S(.18, .19, length(uv-vec2(.21, .09))); //将0-.41部分的y值重映射到0-.75,再与highlight的1范围相乘,结果为纵向渐变 col.rgb = mix(col.rgb, vec3(1.), highlight); d = length(uv-vec2(.25, -.2)); float cheek = S(.2, .01, d)*.4; cheek *= S(.16, .15, d);//大于.16压黑 col.rgb = mix(col.rgb, vec3(.8, .4, .6), cheek); return col; } vec4 Smiley(vec2 uv) { vec4 col = vec4(0.); uv.x = abs(uv.x); vec4 head = Head(uv); vec4 eye = Eye(within(uv, vec4(.03, -.1, .36, .25))); vec4 mouth = Mouth(within(uv, vec4(-.3, -.4, .3, -.1))); vec4 brow = Brow(within(uv, vec4(.03, .2, .4, .43))); col = mix(col, head, head.a);//根据head的透明度混合col和head? col = mix(col, eye, eye.a); col = mix(col, mouth, mouth.a); col = mix(col, brow, brow.a); return col; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= .5; uv.x *= iResolution.x/iResolution.y; // Output to screen fragColor = Smiley(uv); } 怒·完整代码\r#\r#define S(a, b, t) smoothstep(a, b, t) #define sat(x) clamp(x, 0., 1.) float remap01(float a, float b, float t) { return sat((t-a)/(b-a)); } float remap(float a, float b, float c, float d, float t) { return sat((t-a)/(b-a)*(d-c) + c); } vec2 inBox(vec2 uv, vec4 rect) { return (uv-rect.xy)/(rect.zw-rect.xy); } vec4 Brow(vec2 uv) { float y = uv.y; uv.y -= uv.x*.7-1.1; uv -= .5; vec4 col = vec4(0.); float blur = .1; float d1 = length(uv); float s1 = S(.45, .45-blur, d1); float d2 = length(uv-vec2(-.05, -.35)*.7); float s2 = S(.5, .5-blur, d2); float browMask = sat(s1-s2); float colMask = remap01(.2, -.3, y)*.3; colMask *= S(.6, .9, browMask); vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), colMask); uv.y += .1; blur += .1; d1 = length(uv); s1 = S(.45, .45-blur, d1); d2 = length(uv-vec2(-.05, -.35)*.7); s2 = S(.5, .5-blur, d2); float shadowMask = sat(s1-s2); col = mix(col, vec4(0.,0.,0.,1.), S(.0, 1., shadowMask)*.5); col = mix(col, browCol, S(.2, .4, browMask)); return col; } vec4 Eye(vec2 uv) { uv -= .5; float d = length(uv); //眼球 vec4 irisCol = vec4(.2, .2, .5, 1.); vec4 col = mix(vec4(1.), vec4(.8, .2, .2, 1.), S(.3, .7, d)); col.a = S(.5, .48, d); //虹膜边框 col.rgb = mix(col.rgb, vec3(0.), S(.3, .28, d)); //虹膜 irisCol.rgb *= 1. + S(.3, .05, d); col.rgb = mix(col.rgb, irisCol.rgb, S(.28, .25, d)); //瞳孔 col.rgb = mix(col.rgb, vec3(0.), S(.16, .14, d)); //高光 //float highlight = S(.1, .09, length(uv-vec2(-.15,.15))); float highlight = S(.07, .05, length(uv-vec2(.08,-.08))); col.rgb = mix(col.rgb, vec3(1.), highlight); //鼻梁 col.rgb *= 1. - S(.45, .5, d)*.5 * sat(-uv.y-uv.x); return col; } vec4 Mouth(vec2 uv) { uv -= .5; uv.y *= 3.; uv.y += uv.x*uv.x*3.; float d = length(uv); vec4 col = vec4(0.5, .18, .05, 1.); col.a = S(.5, .48, d); float td = length(uv-vec2(0., .4)); vec3 toothCol = vec3(1.) * S(.6, .35, d); col.rgb = mix(col.rgb, toothCol, S(.3, .28, td)); return col; } vec4 Head(vec2 uv) { vec4 col = vec4(1.); float d = length(uv); col.a = S(.5, .48, d); //渐变 vec3 Cola = mix(vec3(1., .2, .2), vec3(1.), -d); vec3 Colb = mix(vec3(1., 1., 0.), vec3(1.), d); col.rgb = mix(Cola, Colb, .4); //阴影 float edgeShade = remap01(.35, .5, d); edgeShade *= edgeShade; col.rgb *= 1. - edgeShade*.5; //高光 float highlight = S(.41, .405, d); highlight *= remap(.41, -.1, .65, 0., uv.y); ////眼眶 highlight *= S(.18, .19, length(uv-vec2(.20, -.0))); col.rgb = mix(col.rgb, vec3(1.), highlight); //轮廓 col.rgb = mix(col.rgb, vec3(.8, .1, .1), S(.45, .48, d)); //腮红 d = length(uv - vec2(.25, -.08)); float cheek = S(.2, .01, d)*.4; cheek *= S(.16, .15, d); col.rgb = mix(col.rgb, vec3(.8, .1, .1), cheek); return col; } vec4 Smiley(vec2 uv) { vec4 col = vec4(0.); vec4 head = Head(uv); vec4 eye = Eye(inBox(uv, vec4(.03, -.15, .35, .17))); vec4 mouth = Mouth(inBox(uv, vec4(-.2, -.35, .2, -.05))); vec4 brow = Brow(inBox(uv, vec4(.0, .2, .35, .43))); col = mix(col, head, head.a); col = mix(col, eye, eye.a); col = mix(col, mouth, mouth.a); col = mix(col, brow, brow.a); return col; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= .5; uv.x *= iResolution.x/iResolution.y; uv.x = abs(uv.x); // Output to screen fragColor = Smiley(uv); } 总结\r#\r这个教程是The Art Of Code的系列教程\rShadertoy Tutorial 播放列表中的第二个小部分，包括制作笑脸和让笑脸动起来两集，之后会把这个系列的所有视频的笔记都发上来。本篇的重点总结：\n在制作笑脸这集中没讲啥新东西，主要就是二维重映射的应用和操作坐标系的具体实践 Shadertoy(\rhttps://www.shadertoy.com/new ) 本集原始链接 Youtube 保留所有版权 首次上传：2024年07月06日 最后修改：2024年07月06日 "},{"id":3,"href":"/ravsoch/posts/ShadertoyTutorial/","title":"聪明绝顶Shader教程[The Art of Code(1-4)]","section":"posts","content":" PART1.JUST A CIRCLE\r#\rShadertoy 是一个通过 WebGL 创建和共享着色器的在线社区和工具，用于在网络浏览器中学习和教授 3D 计算机图形。\nShadertoy中只有片段着色器，通过输入 像素坐标(fragCoord) 并输出对应像素的 rgba值(fragcolor) 来生成图像。\n在\rShadertoy 上新建项目后，将本部分完整代码粘贴到shadertoy中，按下代码编辑器下方的播放键(或Alt + Enter)，图像输出区会显示一个边缘模糊的圆形。\n阅读代码不难理解主函数通过输入像素坐标(fragCoord)，和输出像素颜色(fragColor)来逐一处理每一个像素。\n坐标系的常见操作：\nvec2 uv = fragCoord/iResolution.xy; 将屏幕像素坐标归一化，方便后续操作，iResolution是Shadertoy定义的屏幕尺寸变量 uv -= 0.5; 将uv坐标系的原点移动到屏幕中心 uv.x *= iResolution.x/iResolution.y; 拉伸uv.x坐标，如果屏幕比为1，则对uv坐标的x轴无影响，如果屏幕比大于或小于1,会将uv.x拉伸或压缩，以适应不同的屏幕分辨率 float d = length(uv); 取uv矢量的长度，并使用smoothstep函数float c = smoothstep(r+0.1,r,d); 实现圆形距离场。\n更多2D距离场:\r2D distance functions 函数使用方法查看\r内置函数库 PART1完整代码\r#\rvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= 0.5;// -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float d = length(uv); float r =0.3; float c = smoothstep(r+0.1,r,d); fragColor = vec4(vec3(c),1.0); } PART1截图：\rPART2.BUILDING STUFF WITH CIRCLE\r#\r把上一部分的Circle函数整理出来 float Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } 使用Circle函数画出脸和眼睛(多个圆相减) 可以尝试改变圆的位置和改变符号，比如mask += Circle(), 因为圆的部分值为1，两个圆相减后交集值为0，从而实现相减效果 float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); 创建一个颜色，然后与musk取交集 mask是0到1之间的数，rgb值也是0到1之间的数，相乘后即可在屏幕中留下mask\u0026gt;0的部分 vec3 col = vec3(.5,0.4,.6)*mask; 创建嘴巴，经过标准化处理后加入musk中 float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = clamp(mouth, 0., 1.); //将值置于0到1之间 mask -= mouth; PART2完整代码\r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = clamp(mouth, 0., 1.); mask -= mouth; vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART2截图：\rPART3.ROTO-ZOOMING SMILEY \u0026amp; MAKING A RECTANGLE\r#\rRoto-Zooming\r#\r详细的Roto-Zooming原理查看\rThe Art of Demomaking - Issue 10 - Roto-Zooming 首先打包笑脸函数，并实现位置、大小、旋转角度的控制 要注意旋转算法分为两步，都需要原始的uv值，如果计算uv.y时使用了更新后的uv.x，会导致结果出错，图像失真拉伸。 float Smiley(vec2 uv, vec2 p, float size, float angle) { //这里的uv相当于小元素自己的坐标系统 vec2 uv_orig = uv;//旋转算法分为两步，需要保存原始uv值备用 uv.x = uv_orig.x*cos(angle) - uv_orig.y*sin(angle);//rotate uv.y = uv_orig.y*cos(angle) + uv_orig.x*sin(angle); uv -= p;//translating uv /= size;//scaling float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; return mask; } 在Smiley函数中添加Scale，可以实现Roto-Zooming效果 Smiley(): uv /= scale; mainImage(): float scale = 1.+.5*sin(iTime);//简单的周期函数，返回值随时间变化，实现“Zooming”部分 //角度参数传入iTime(Shadertoy定义的时间变量，等于显示区下方的那个数字，实现“Roto-”部分) float mask = Smiley(uv, vec2(0., .0), 1., iTime, scale); 实现矩形函数： 带子函数： smoothstep(a, b, t), t \u0026lt; a, 返回0.0， t \u0026gt; b, 返回1.0, 否则返回Hermite插值，当a \u0026gt; b时，smoothstep函数将反转 运用两个smoothstep函数结果求交集，将显示给定边缘的“带子” 矩形函数： 运用两个band函数结果求交集，将显示给定边缘的矩形 //带子函数 float Band(float t, float start, float end, float blur) { //PART4中为了显示效果，blur不再/2. float step1 = smoothstep(start-blur/2., start+blur/2., t); float step2 = smoothstep(end+blur/2., end-blur/2., t); return step1*step2; } //矩形函数 float Rect(vec2 uv, vec2 p, vec2 size, float blur) { uv -= p; float band1 = Band(uv.x, -size.x/2., size.x/2., blur); float band2 = Band(uv.y, -size.y/2., size.y/2., blur); return band1 * band2; } //也可以传入上下左右来定义矩形 //下一部分会使用这个版本的矩形函数 float Rect(vec2 uv, float left, float right, float bottom, float top, float blur) { float band1 = Band(uv.x, left, right, blur); float band2 = Band(uv.y, bottom, top, blur); return band1 * band2; } PART3完整代码\r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } float Band(float t, float start, float end, float blur) { float step1 = smoothstep(start-blur/2., start+blur/2., t); float step2 = smoothstep(end+blur/2., end-blur/2., t); return step1*step2; } float Rect(vec2 uv, vec2 p, vec2 size, float blur) { uv -= p; float band1 = Band(uv.x, -size.x/2., size.x/2., blur); float band2 = Band(uv.y, -size.y/2., size.y/2., blur); return band1 * band2; } float Smiley(vec2 uv, vec2 p, float size, float angle, float scale) { //这里的uv相当于小元素自己的坐标系统 uv -= p;//translating uv /= size;//scaling uv /= scale; vec2 uv_orig = uv;//旋转算法分为两步，需要保存原始uv值备用 uv.x = uv_orig.x*cos(angle) - uv_orig.y*sin(angle);//rotate uv.y = uv_orig.y*cos(angle) + uv_orig.x*sin(angle); float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; return mask; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float scale = 1.+.5*sin(iTime); //float mask = Smiley(uv, vec2(0., .0), 1., iTime, scale);//Roto-Zooming float mask = Rect(uv, vec2(.4,0.), vec2(.4, .3), .01); vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART3截图 Roto-Zooming Smiley\nRectangle\nPART4.DOMAIN DISTORTION\r#\r通过操作坐标系，实现变形效果 注：这一PART使用的是上下左右传参的Rect()(上一部分已给出) //为了操作方便 float x = uv.x; float y = uv.y; //以下操作可以实现剪切,使x值上的线倾斜，y同理 x += y*0.2; //对边进行操作可以实现不同的四边形 float mask = Rect(vec2(x, y),-.3+y*.2, .3-y*.2, -.2, .2, .01);//比如梯形 下面的代码实现了矩形的弯曲\n使用图形计算器\rDesmos 可以方便的找到图形函数，应用到shader中 因为y减去对应的m，图形在屏幕上的位置会对应上移 比如点uv.y:(0.5,0), 减去该位置m后，y:(0.5,-0.25), 而矩形函数中这个点应该画在(0.5,0)位置，而原先的位置已经变为(0.5,-0.25)，所以图形上移。 float m = x*x; float y = uv.y - m; 使用sin()和iTime，操作矩形周期运动 设定sin函数的幅值和频率，找到好的显示效果 float m = sin(iTime+x*8.)*.1; float y = uv.y - m; 重映射\r#\r重映射是一个常见的操作，从一个域映射一个值到另一个域 归一化和重映射：(很简单，但为了理解这个我还画了一个图) float remap01(float a, float b, float t)//映射到01之间 { return (t-a)/(b-a); } float remap(float a, float b, float c, float d, float t)//映射到目标域 { return c + (d-c)*remap01(a, b, t); } //可以化简为一个函数 float remap(float a, float b, float c, float d, float t) { return c+ (d-c)*(t-a)/(b-a); } 将矩形设置为长条状并让它像旗子一样🚩飘起来 float m = sin(iTime+x*8.)*.1; float mask = Rect(vec2(x,y),-.5, .5, -.1, .1, blur); 将像素坐标x值(-.5, .5)从坐标轴映射到模糊程度(.01, .25) float blur = remap(-.5, .5, .01, .25, x);//线性映射 blur = pow(blur*4., 2.);//非线性映射 PART4完整代码\r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } float Band(float t, float start, float end, float blur) { //float step1 = smoothstep(start-blur/2., start+blur/2., t); //float step2 = smoothstep(end+blur/2., end-blur/2., t); float step1 = smoothstep(start-blur, start+blur, t); float step2 = smoothstep(end+blur, end-blur, t); return step1*step2; } float Rect(vec2 uv, float left, float right, float bottom, float top, float blur) { float band1 = Band(uv.x, left, right, blur); float band2 = Band(uv.y, bottom, top, blur); return band1 * band2; } float remap01(float a, float b, float t) { return (t-a)/(b-a); } float remap(float a, float b, float c, float d, float t) { return c + (d-c)*remap01(a, b, t); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float x = uv.x; float m = sin(iTime+x*8.)*.1; float y = uv.y - m; float blur = remap(-.5, .5, .01, .25, x); blur = pow(blur*4., 2.); float mask = Rect(vec2(x,y),-.5, .5, -.1, .1, blur); vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART4截图\n变形和重映射的理解\n最终效果\n总结\r#\r这个教程是The Art Of Code的系列教程\rShadertoy Tutorial 播放列表中的第一个小部分，之后会把这个系列的所有视频的笔记都发上来。本篇的重点总结：\n搞懂Shader是什么，以片元着色器来说，对每一个像素，传入该像素的坐标值，传出该像素的颜色值，组成图像。 对坐标系的基础操作，比如归一化、中心化、屏幕比例调整。以及代码中uv的具体含义。 重映射是常用操作，将一个值从一个域映射到另一个域，归一化01映射和线性映射后，可以操作映射后的值实现非线性映射。 Shadertoy(\rhttps://www.shadertoy.com/new )\n保留所有版权 首次上传：2024年07月04日 最后修改：2024年07月05日 "}]