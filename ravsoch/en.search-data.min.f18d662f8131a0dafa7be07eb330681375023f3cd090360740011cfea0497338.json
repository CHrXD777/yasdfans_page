[{"id":0,"href":"/ravsoch/posts/","title":"posts","section":"æ¬¢è¿","content":""},{"id":1,"href":"/ravsoch/posts/ShadertoyTutorial/","title":"èªæ˜ç»é¡¶Shaderæ•™ç¨‹","section":"posts","content":" PART1.JUST A CIRCLE\r#\rShadertoy æ˜¯ä¸€ä¸ªé€šè¿‡ WebGL åˆ›å»ºå’Œå…±äº«ç€è‰²å™¨çš„åœ¨çº¿ç¤¾åŒºå’Œå·¥å…·ï¼Œç”¨äºåœ¨ç½‘ç»œæµè§ˆå™¨ä¸­å­¦ä¹ å’Œæ•™æˆ 3D è®¡ç®—æœºå›¾å½¢ã€‚\nShadertoyä¸­åªæœ‰ç‰‡æ®µç€è‰²å™¨ï¼Œé€šè¿‡è¾“å…¥ åƒç´ åæ ‡(fragCoord) å¹¶è¾“å‡ºå¯¹åº”åƒç´ çš„ rgbaå€¼(fragcolor) æ¥ç”Ÿæˆå›¾åƒã€‚\nåœ¨\rShadertoy ä¸Šæ–°å»ºé¡¹ç›®åï¼Œå°†æœ¬éƒ¨åˆ†å®Œæ•´ä»£ç ç²˜è´´åˆ°shadertoyä¸­ï¼ŒæŒ‰ä¸‹ä»£ç ç¼–è¾‘å™¨ä¸‹æ–¹çš„æ’­æ”¾é”®(æˆ–Alt + Enter)ï¼Œå›¾åƒè¾“å‡ºåŒºä¼šæ˜¾ç¤ºä¸€ä¸ªè¾¹ç¼˜æ¨¡ç³Šçš„åœ†å½¢ã€‚\né˜…è¯»ä»£ç ä¸éš¾ç†è§£ä¸»å‡½æ•°é€šè¿‡è¾“å…¥åƒç´ åæ ‡(fragCoord)ï¼Œå’Œè¾“å‡ºåƒç´ é¢œè‰²(fragColor)æ¥é€ä¸€å¤„ç†æ¯ä¸€ä¸ªåƒç´ çš„å€¼ã€‚\nuvçš„å¸¸è§æ“ä½œï¼š\nvec2 uv = fragCoord/iResolution.xy; å°†å±å¹•åƒç´ åæ ‡å½’ä¸€åŒ–ï¼Œæ–¹ä¾¿åç»­æ“ä½œ uv -= 0.5; å°†uvåæ ‡ç³»çš„åŸç‚¹ç§»åŠ¨åˆ°å±å¹•ä¸­å¿ƒ uv.x *= iResolution.x/iResolution.y; æ‹‰ä¼¸uv.xåæ ‡ï¼Œå¦‚æœå±å¹•æ¯”ä¸º1ï¼Œåˆ™å¯¹uvåæ ‡çš„xè½´æ— å½±å“ï¼Œå¦‚æœå±å¹•æ¯”å¤§äºæˆ–å°äº1,ä¼šå°†uv.xæ‹‰ä¼¸æˆ–å‹ç¼©ï¼Œä»¥é€‚åº”ä¸åŒçš„å±å¹•åˆ†è¾¨ç‡ float d = length(uv); å–uvçŸ¢é‡çš„é•¿åº¦ï¼Œå¹¶ä½¿ç”¨smoothstepå‡½æ•°float c = smoothstep(r+0.1,r,d); å®ç°åœ†å½¢è·ç¦»åœºã€‚\næ›´å¤š2Dè·ç¦»åœº:\r2D distance functions å‡½æ•°ä½¿ç”¨æ–¹æ³•æŸ¥çœ‹\rå†…ç½®å‡½æ•°åº“ PART1å®Œæ•´ä»£ç \r#\rvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; // Output to screen uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float d = length(uv); float r =0.3; float c = smoothstep(r+0.1,r,d); fragColor = vec4(vec3(c),1.0); } PART1æˆªå›¾ï¼š\rPART2.BUILDING STUFF WITH CIRCLE\r#\ræ•´ç†å‡ºæ¥Circleå‡½æ•° float Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } ä½¿ç”¨circleå‡½æ•°ç”»å‡ºè„¸å’Œçœ¼ç›(å¤šä¸ªåœ†ç›¸å‡) float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); åˆ›å»ºä¸€ä¸ªé¢œè‰²ï¼Œç„¶åä¸muskå–äº¤é›† vec3 col = vec3(.5,0.4,.6)*mask; åˆ›å»ºå˜´å·´ï¼Œç»è¿‡æ ‡å‡†åŒ–å¤„ç†ååŠ å…¥muskä¸­ float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); //æ ‡å‡†åŒ–ï¼Œå°†å€¼ç½®äº0åˆ°1ä¹‹é—´ mask -= mouth; PART2å®Œæ•´ä»£ç \r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; // Output to screen uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART2æˆªå›¾ï¼š\rPART3.ROTO-ZOOMING SMILEY \u0026amp; MAKING A RECTANGLE\r#\rRoto-Zooming\r#\rè¯¦ç»†çš„Roto-ZoomingåŸç†æŸ¥çœ‹\rThe Art of Demomaking - Issue 10 - Roto-Zooming é¦–å…ˆæ‰“åŒ…ç¬‘è„¸å‡½æ•°ï¼Œå¹¶å®ç°ä½ç½®ã€å¤§å°ã€æ—‹è½¬è§’åº¦çš„æ§åˆ¶ è¦æ³¨æ„æ—‹è½¬ç®—æ³•åˆ†ä¸ºä¸¤æ­¥ï¼Œéƒ½éœ€è¦åŸå§‹çš„uvå€¼ï¼Œå¦‚æœè®¡ç®—uv.yæ—¶ä½¿ç”¨äº†æ›´æ–°åçš„uv.xï¼Œä¼šå¯¼è‡´ç»“æœå‡ºé”™ï¼Œå›¾åƒå¤±çœŸæ‹‰ä¼¸ã€‚ float Smiley(vec2 uv, vec2 p, float size, float angle) { //è¿™é‡Œçš„uvç›¸å½“äºå°å…ƒç´ è‡ªå·±çš„åæ ‡ç³»ç»Ÿ vec2 uv_orig = uv;//æ—‹è½¬ç®—æ³•åˆ†ä¸ºä¸¤æ­¥ï¼Œéœ€è¦ä¿å­˜åŸå§‹uvå€¼å¤‡ç”¨ uv.x = uv_orig.x*cos(angle) - uv_orig.y*sin(angle);//rotate uv.y = uv_orig.y*cos(angle) + uv_orig.x*sin(angle); uv -= p;//translating uv /= size;//scaling float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; return mask; } åœ¨Smileyå‡½æ•°ä¸­æ·»åŠ Scaleï¼Œå¯ä»¥å®ç°Roto-Zoomingæ•ˆæœ Smiley(): uv /= scale; mainImage(): float scale = 1.+.5*sin(iTime);//ç®€å•çš„å‘¨æœŸå‡½æ•°ï¼Œè¿”å›å€¼éšæ—¶é—´å˜åŒ–ï¼Œå®ç°â€œZoomingâ€éƒ¨åˆ† //è§’åº¦å‚æ•°ä¼ å…¥iTime(Shadertoyå®šä¹‰çš„æ—¶é—´å˜é‡ï¼Œç­‰äºæ˜¾ç¤ºåŒºä¸‹æ–¹çš„é‚£ä¸ªæ•°å­—ï¼Œå®ç°â€œRoto-â€éƒ¨åˆ†) float mask = Smiley(uv, vec2(0., .0), 1., iTime, scale); å®ç°çŸ©å½¢å‡½æ•°ï¼š å¸¦å­å‡½æ•°ï¼š smoothstep(a, b, t), t \u0026lt; a, è¿”å›0.0ï¼Œ t \u0026gt; b, è¿”å›1.0, å¦åˆ™è¿”å›Hermiteæ’å€¼ï¼Œå½“a \u0026gt; bæ—¶ï¼Œsmoothstepå‡½æ•°å°†åè½¬ è¿ç”¨ä¸¤ä¸ªsmoothstepå‡½æ•°ç»“æœæ±‚äº¤é›†ï¼Œå°†æ˜¾ç¤ºç»™å®šè¾¹ç¼˜çš„â€œå¸¦å­â€ çŸ©å½¢å‡½æ•°ï¼š è¿ç”¨ä¸¤ä¸ªbandå‡½æ•°ç»“æœæ±‚äº¤é›†ï¼Œå°†æ˜¾ç¤ºç»™å®šè¾¹ç¼˜çš„çŸ©å½¢ //å¸¦å­å‡½æ•° float Band(float t, float start, float end, float blur) { //PART4ä¸­ä¸ºäº†æ˜¾ç¤ºæ•ˆæœï¼Œblurä¸å†/2. float step1 = smoothstep(start-blur/2., start+blur/2., t); float step2 = smoothstep(end+blur/2., end-blur/2., t); return step1*step2; } //çŸ©å½¢å‡½æ•° float Rect(vec2 uv, vec2 p, vec2 size, float blur) { uv -= p; float band1 = Band(uv.x, -size.x/2., size.x/2., blur); float band2 = Band(uv.y, -size.y/2., size.y/2., blur); return band1 * band2; } //ä¹Ÿå¯ä»¥ä¼ å…¥ä¸Šä¸‹å·¦å³æ¥å®šä¹‰çŸ©å½¢ //ä¸‹ä¸€éƒ¨åˆ†ä¼šä½¿ç”¨è¿™ä¸ªç‰ˆæœ¬çš„çŸ©å½¢å‡½æ•° float Rect(vec2 uv, float left, float right, float bottom, float top, float blur) { float band1 = Band(uv.x, left, right, blur); float band2 = Band(uv.y, bottom, top, blur); return band1 * band2; } PART3å®Œæ•´ä»£ç \r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } float Band(float t, float start, float end, float blur) { float step1 = smoothstep(start-blur/2., start+blur/2., t); float step2 = smoothstep(end+blur/2., end-blur/2., t); return step1*step2; } float Rect(vec2 uv, vec2 p, vec2 size, float blur) { uv -= p; float band1 = Band(uv.x, -size.x/2., size.x/2., blur); float band2 = Band(uv.y, -size.y/2., size.y/2., blur); return band1 * band2; } float Smiley(vec2 uv, vec2 p, float size, float angle, float scale) { //è¿™é‡Œçš„uvç›¸å½“äºå°å…ƒç´ è‡ªå·±çš„åæ ‡ç³»ç»Ÿ uv -= p;//translating uv /= size;//scaling uv /= scale; vec2 uv_orig = uv;//æ—‹è½¬ç®—æ³•åˆ†ä¸ºä¸¤æ­¥ï¼Œéœ€è¦ä¿å­˜åŸå§‹uvå€¼å¤‡ç”¨ uv.x = uv_orig.x*cos(angle) - uv_orig.y*sin(angle);//rotate uv.y = uv_orig.y*cos(angle) + uv_orig.x*sin(angle); float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; return mask; } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; // Output to screen uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float scale = 1.+.5*sin(iTime); //float mask = Smiley(uv, vec2(0., .0), 1., iTime, scale);//Roto-Zooming float mask = Rect(uv, vec2(.4,0.), vec2(.4, .3), .01); vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART3æˆªå›¾ Roto-Zooming Smiley\nRectangle\nPART4.DOMAIN DISTORTION\r#\ré€šè¿‡æ“ä½œuv(å³å…ƒç´ è‡ªå·±çš„åæ ‡ç³»)ï¼Œå®ç°å˜å½¢æ•ˆæœ æ³¨ï¼šè¿™ä¸€PARTä½¿ç”¨çš„æ˜¯ä¸Šä¸‹å·¦å³ä¼ å‚çš„Rect()å‡½æ•°(ä¸Šä¸€éƒ¨åˆ†å·²ç»™å‡º) //ä¸ºäº†çœ‹èµ·æ¥æ–¹ä¾¿ä¸€äº› float x = uv.x; float y = uv.y; //å‰ªåˆ‡,ä½¿xå€¼ä¸Šçš„çº¿å€¾æ–œï¼ŒyåŒç† x += y*0.2; //å¯¹è¾¹è¿›è¡Œæ“ä½œå¯ä»¥å®ç°ä¸åŒçš„å››è¾¹å½¢ float mask = Rect(vec2(x, y),-.3+y*.2, .3-y*.2, -.2, .2, .01);//æ¯”å¦‚æ¢¯å½¢ ä¸‹é¢çš„ä»£ç å®ç°äº†çŸ©å½¢çš„å¼¯æ›²\nä½¿ç”¨å›¾å½¢è®¡ç®—å™¨\rDesmoså¯ä»¥æ–¹ä¾¿çš„æ‰¾åˆ°å›¾å½¢å‡½æ•°ï¼Œåº”ç”¨åˆ°shaderä¸­ å› ä¸ºyå‡å»å¯¹åº”çš„mï¼Œå›¾å½¢åœ¨å±å¹•ä¸Šçš„ä½ç½®ä¼šå¯¹åº”ä¸Šç§» æ¯”å¦‚ç‚¹uv.y:(0.5,0), å‡å»è¯¥ä½ç½®måï¼Œy:(0.5,-0.25), è€ŒçŸ©å½¢å‡½æ•°ä¸­è¿™ä¸ªç‚¹åº”è¯¥ç”»åœ¨(0.5,0)ä½ç½®ï¼Œè€ŒåŸå…ˆçš„ä½ç½®å·²ç»å˜ä¸º(0.5,-0.25)ï¼Œæ‰€ä»¥å›¾å½¢ä¸Šç§»ã€‚ float m = x*x; float y = uv.y - m; ä½¿ç”¨sin()å’ŒiTimeï¼Œæ“ä½œçŸ©å½¢å‘¨æœŸè¿åŠ¨ æ“æ§sinå‡½æ•°çš„å¹…å€¼å’Œé¢‘ç‡ï¼Œæ‰¾åˆ°å¥½çš„æ˜¾ç¤ºæ•ˆæœ float m = sin(iTime+x*8.)*.1; float y = uv.y - m; é‡æ˜ å°„\r#\ré‡æ˜ å°„æ˜¯ä¸€ä¸ªå¸¸è§çš„æ“ä½œï¼Œæ˜ å°„ä¸€ä¸ªå€¼ä»ä¸€ä¸ªåŸŸåˆ°å¦ä¸€ä¸ªåŸŸ å½’ä¸€åŒ–å’Œé‡æ˜ å°„ï¼š(å¾ˆç®€å•ï¼Œä½†ä¸ºäº†ç†è§£è¿™ä¸ªæˆ‘è¿˜ç”»äº†ä¸€ä¸ªå›¾) float remap01(float a, float b, float t) { return (t-a)/(b-a); } float remap(float a, float b, float c, float d, float t) { return c + (d-c)*remap01(a, b, t); } å°†çŸ©å½¢è®¾ç½®ä¸ºé•¿æ¡çŠ¶å¹¶è®©å®ƒåƒæ——å­ä¸€æ ·ğŸš©é£˜èµ·æ¥ float m = sin(iTime+x*8.)*.1; float mask = Rect(vec2(x,y),-.5, .5, -.1, .1, blur); å°†åƒç´ åæ ‡xå€¼(-.5, .5)ä»åæ ‡è½´æ˜ å°„åˆ°æ¨¡ç³Šç¨‹åº¦(.01, .25) float blur = remap(-.5, .5, .01, .25, x);//çº¿æ€§æ˜ å°„ blur = pow(blur*4., 2.);//éçº¿æ€§æ˜ å°„ PART4å®Œæ•´ä»£ç \r#\rfloat Circle(vec2 uv, vec2 p, float r, float blur) { float d = length(uv-p); float c = smoothstep(r+blur,r,d); return c; } float Band(float t, float start, float end, float blur) { //float step1 = smoothstep(start-blur/2., start+blur/2., t); //float step2 = smoothstep(end+blur/2., end-blur/2., t); float step1 = smoothstep(start-blur, start+blur, t); float step2 = smoothstep(end+blur, end-blur, t); return step1*step2; } float Rect(vec2 uv, float left, float right, float bottom, float top, float blur) { float band1 = Band(uv.x, left, right, blur); float band2 = Band(uv.y, bottom, top, blur); return band1 * band2; } float Smiley(vec2 uv, vec2 p, float size, float angle, float scale) { //è¿™é‡Œçš„uvç›¸å½“äºå°å…ƒç´ è‡ªå·±çš„åæ ‡ç³»ç»Ÿ uv -= p;//translating uv /= size;//scaling uv /= scale; vec2 uv_orig = uv;//æ—‹è½¬ç®—æ³•åˆ†ä¸ºä¸¤æ­¥ï¼Œéœ€è¦ä¿å­˜åŸå§‹uvå€¼å¤‡ç”¨ uv.x = uv_orig.x*cos(angle) - uv_orig.y*sin(angle);//rotate uv.y = uv_orig.y*cos(angle) + uv_orig.x*sin(angle); float mask = Circle(uv, vec2(0.,0.), .4, .03); mask -= Circle(uv, vec2(-.15,.12), .07, .02); mask -= Circle(uv, vec2(.15,.12), .07, .02); float mouth = Circle(uv, vec2(0.,0.), .3, .03); mouth -= Circle(uv, vec2(0.,0.45), .5, .03); mouth = smoothstep(0.,1.,mouth); mask -= mouth; return mask; } float remap01(float a, float b, float t) { return (t-a)/(b-a); } float remap(float a, float b, float c, float d, float t) { return c + (d-c)*remap01(a, b, t); } void mainImage( out vec4 fragColor, in vec2 fragCoord ) { // Normalized pixel coordinates (from 0 to 1) vec2 uv = fragCoord/iResolution.xy; // Output to screen uv -= 0.5;//remap to -0.5 to 0.5 uv.x *= iResolution.x/iResolution.y; float x = uv.x; float m = sin(iTime+x*8.)*.1; float y = uv.y - m; //float scale = 1.+.5*sin(iTime); //float mask = Smiley(uv, vec2(0., .0), 1., iTime, scale);//Roto-Zooming //float mask = Rect(uv,-.5, .5, -.1, .1, .01); float blur = remap(-.5, .5, .01, .25, x); blur = pow(blur*4., 2.); float mask = Rect(vec2(x,y),-.5, .5, -.1, .1, blur); vec3 col = vec3(.5,0.4,.6)*mask; fragColor = vec4(col,1.0); } PART4æˆªå›¾\nå˜å½¢å’Œé‡æ˜ å°„çš„ç†è§£\næœ€ç»ˆæ•ˆæœ\næ€»ç»“\r#\rè¿™ä¸ªæ•™ç¨‹æ˜¯The Art Of Codeçš„ç³»åˆ—æ•™ç¨‹\rShadertoy Tutorial æ’­æ”¾åˆ—è¡¨ä¸­çš„ç¬¬ä¸€ä¸ªå°éƒ¨åˆ†ï¼Œä¹‹åä¼šæŠŠè¿™ä¸ªç³»åˆ—çš„æ‰€æœ‰è§†é¢‘çš„ç¬”è®°éƒ½å‘ä¸Šæ¥ã€‚æœ¬ç¯‡çš„é‡ç‚¹æ€»ç»“ï¼š\nææ‡‚Shaderæ˜¯ä»€ä¹ˆï¼Œä»¥ç‰‡å…ƒç€è‰²å™¨æ¥è¯´ï¼Œå¯¹æ¯ä¸€ä¸ªåƒç´ ï¼Œä¼ å…¥è¯¥åƒç´ çš„åæ ‡å€¼ï¼Œä¼ å‡ºè¯¥åƒç´ çš„é¢œè‰²å€¼ï¼Œå½¢æˆå›¾åƒã€‚ å¯¹uvçš„åŸºç¡€æ“ä½œï¼Œæ¯”å¦‚å½’ä¸€åŒ–ã€ä¸­å¿ƒåŒ–ã€å±å¹•æ¯”ä¾‹è°ƒæ•´ã€‚ä»¥åŠå‡ºç°ä½ç½®ä¸åŒçš„uvä»£è¡¨ä»€ä¹ˆï¼Œæ¯”å¦‚å¯¹å…·ä½“å…ƒç´ æ¥è¯´ï¼Œæ˜¯è°ƒæ•´å®ƒè‡ªå·±çš„åæ ‡ç³»ã€‚ é‡æ˜ å°„ç»å¸¸ä¼šç”¨åˆ°ï¼Œå°†ä¸€ä¸ªå€¼ä»ä¸€ä¸ªåŸŸæ˜ å°„åˆ°å¦ä¸€ä¸ªåŸŸï¼Œå½’ä¸€åŒ–01æ˜ å°„å’Œçº¿æ€§æ˜ å°„åï¼Œå¯ä»¥æ“ä½œæ˜ å°„åçš„å€¼å®ç°éçº¿æ€§æ˜ å°„ã€‚ Shadertoy(\rhttps://www.shadertoy.com/new )\nä¿ç•™æ‰€æœ‰ç‰ˆæƒ é¦–æ¬¡ä¸Šä¼ ï¼š2024å¹´07æœˆ04æ—¥ æœ€åä¿®æ”¹ï¼š2024å¹´07æœˆ04æ—¥ "}]