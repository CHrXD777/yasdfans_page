[{"id":0,"href":"/BeefDoc/docs/BeefDoc/introduction/","title":"介绍","section":"目录","content":" 介绍 # Beef🥩编程语言概述 # Beef 是以面向性能(performance-oriented)的静态编译(statically-compiled)编程语言。该语言和环境(IDE)注重开发者的生产力，同时也非常关注开发、调试和维护 Beef 应用程序的整体愉悦性。目标受众是注重性能的开发者，他们看重简洁、代码可读性、快速开发迭代和良好的调试能力。\n设计目标 # 高性能执行 无 GC 或引用计数开销 最小化运行时 编译（无 JIT 延迟） 内存控制 广泛支持自定义分配器 增强对栈内存的控制 与 C 和 C++ 低摩擦互操作 静态或动态链接到常规 C/C++ 库 支持 C/C++ 结构布局和调用约定 在清晰性、可读性或可发现性方面，更倾向于冗长而非简洁 支持流畅的迭代开发 快速的增量编译和链接 运行时代码编译（代码热交换），包括数据布局更改 为目标受众提供熟悉的语法和编程范式（C家族） 良好的调试能力 生成标准的调试信息（PDB/DWARF） 强调调试构建的良好执行速度 适合基于 IDE 的工作流程 编译器即服务 快速而可靠的自动完成结果 快速可靠的重构能力（即重命名符号） 利用 LLVM 基础设施 经过严格测试的后端优化器 ThinLTO 链接时优化支持 "},{"id":1,"href":"/BeefDoc/docs/BeefDoc/LanguageGuide/TheBasic/","title":"基础知识","section":"语言指南","content":" 基础知识 # 编译模型 # 牛肉编译上下文是一个工作区(workspace)，由多个项目(projects)组成。一个项目可以是一个库，也可以是一个二进制文件，如可执行文件或 dll。对源代码进行解析，通过有限的预处理器进行编译，并为引用的类型和方法创建对象文件集，然后将其链接到目标二进制文件中。工作区范围的编译模式允许每个工作区设置影响特定方法或类型组的编译，即使代码包含在引用的第三方库中，也能修改预处理器和编译设置（即：优化级别）。\n支持增量编译，通过依赖关系图只重建可能受影响的对象，并通过后台缓存避免重建无功能变化的对象。为创建可重现的编译，可禁用增量编译。\nBeef 支持多种编译器后端，包括 LLVM 和自定义的 \u0026ldquo;增强调试\u0026rdquo;（Og+）后端，后者执行了一些代码优化，但不会对调试性产生不利影响，而且与 LLVM 相比，在发布调试信息方面也有一些改进。\n支持多种链接器，包括系统链接器和可用于链接时优化构建（LLVM LTO/ThinLTO）的 LLVM 链接器。\n"},{"id":2,"href":"/BeefDoc/docs/BeefDoc/GettingStart/Install/","title":"安装","section":"入门","content":" 安装 # 稳定版本 # 版本：0.43.3 发布日期：2022 年 9 月 7 日\nWindows 64 位： 下载\n"},{"id":3,"href":"/BeefDoc/docs/BeefDoc/GettingStart/BuildingfromSource/","title":"从源代码构建","section":"入门","content":" 从源代码构建 # 构建概述 # 在具有可用的二进制发行版的平台上（例如 Windows），无需从源代码构建 Beef。\n源代码可在 https://github.com/beefytech/Beef 获取。\n引导 # Beef 编译器的核心部分由 C++ 编写，而集成开发环境和命令行 BeefBuild 编译系统则由 Beef 本身编写。出于引导的目的，Beef 包含了一个最小的引导编译器，其唯一的工作就是执行初始的 BeefBuild 编译，然后再执行自身的 \u0026ldquo;正确 \u0026ldquo;构建。\n在 Windows 上构建 # 要求 # Visual Studio 2017 或更高版本的 Microsoft C++ 构建工具。您可以从 https://visualstudio.microsoft.com/downloads/#build-tools-for-visual-studio-2022 安装 Microsoft Visual C++ Build Tools 或整个 Visual Studio 套件。 Platform Toolset 141 (VS2017) Windows SDK 10.0.17763.0 CMake 3.15 或更新版本 Python 3.6 或更新版本 Git 命令行工具 构建步骤 # 执行 bin/build.bat 注意，这将首先下载并编译 LLVM，这需要一些时间。编译结果将保存在 IDE/dist 中。\n在 Linux 和 macOS 上构建 # 要求 # CMake 3.15 或更新版本 Python 2.7 Git 构建步骤 # 使用 bin/build.sh 构建 Beef 这将构建 LLVM 等依赖项，这可能需要相当长的时间。\n编译结果将保存在 IDE/dist 中。\n请注意，这些平台均支持 BeefBuild 等 CLI 工具，但 IDE 目前仅适用于 Windows。\n"},{"id":4,"href":"/BeefDoc/docs/BeefDoc/LanguageGuide/SafetyFeatrues/","title":"安全特性","section":"语言指南","content":" 安全特性 # Beef 支持多种可选的安全特性，其中许多特性可在 \u0026ldquo;混合安全 \u0026ldquo;编译时对指定代码组禁用（即：性能关键型代码可禁用某些检查，而性能关键型较低或测试较少的代码则可使用更多安全检查）。\n默认情况下，在调试版本中会对所有代码启用以下检查，而在发布版本中则会禁用这些检查。\n边界检查 # 边界检查是在数组、集合、跨度和字符串的标准库中实现的。在许多情况下，它们是通过一个执行边界检查的 [Checked] 访问器和另一个不进行边界检查的 [Unchecked] 访问器来实现的。这样就可以在调用时选择边界检查，而不是在整个集合范围内决定。\n// 禁用此特定索引的边界检查\rint val = arr[[Unchecked]i]; // 在此方法中不做任何检查\r[DisableChecks]\rvoid Calculate()\r{\rint val = arr[i];\r} 动态类型转换检查 # 在运行时会捕捉到将对象显式转换为无效派生类型的情况。\n可通过调试内存管理器实时检测内存泄漏。运行时将持续跟踪可触及的内存，如果内存不再可触及但未被正确释放，则会立即报告为泄漏，并同时报告分配发生的代码位置。这种分配跟踪的堆栈跟踪深度是可调的。 双重释放/释放后使用\n启用调试内存管理器后，被请求释放的对象将被标记为 \u0026ldquo;已释放\u0026rdquo;，但内存不会被实际回收，直到不再有对其占用内存的引用。在内存被标记为释放后，任何使用内存的尝试都会立即失败，被释放对象的值及其分配堆栈跟踪都将有效，并在调试器中可见。\n"},{"id":5,"href":"/BeefDoc/docs/BeefDoc/License/","title":"许可证","section":"目录","content":"MIT 许可证\n版权所有 © 2019 BeefyTech\n特此授予获得本软件和相关文档文件（简称为“本软件”）副本的任何人不受限制地免费使用本软件的权利，包括但不限于使用、复制、修改、合并、发布、分发、再许可和/或销售本软件副本的权利，并且允许获得本软件的人对他人授予前述权利，但须符合以下条件：\n上述版权声明和本许可证声明应包含在本软件的所有副本或主要部分中。\n本软件“按原样”提供，不提供任何明示或暗示的担保，包括但不限于可销售性、适合特定用途和不侵权的担保。 在任何情况下，无论是在合同诉讼、侵权诉讼还是其他类型的诉讼中，作者或版权持有人均不对因本软件、本软件的使用或其它交易行为而引起、产生或与之相关的任何索赔、损害赔偿或其它责任负责，无论是在合同诉讼、侵权诉讼还是其他诉讼中。\n"},{"id":6,"href":"/BeefDoc/docs/BeefDoc/GettingStart/","title":"入门","section":"目录","content":" 入门 # 欢迎使用 Beef # Beef 主要基于集成开发环境，但也支持命令行构建。第一步是安装 Beef 或从源代码构建。目前，二进制文件仅适用于 Windows，Beef IDE 也仅适用于 Windows。\n支持的平台 # 二进制文件可用于 Windows，并支持在 Windows、Linux 和 macOS 上从源代码构建。针对 Android 和 iOS 等目标的交叉编译正在开发中。\n创建基于 IDE 的“Hello World” # 运行 Beef IDE。 通过选择 File/New/Project 创建一个名为 \u0026ldquo;Hello\u0026rdquo; 的新控制台项目。 右键单击新项目，选择 \u0026ldquo;New Class\u0026hellip;\u0026quot;，并输入 \u0026ldquo;Program\u0026rdquo; 作为名称。 在新创建的文件中输入以下文本。 using System;\rnamespace Hello\r{\rclass Program\r{\rstatic void Main()\r{\rConsole.WriteLine(\u0026#34;Hello, world!\u0026#34;);\r}\r}\r} 按下 F5 编译并执行 创建基于命令行的“Hello World” # 在某个地方创建一个名为 \u0026ldquo;Hello\u0026rdquo; 的新目录。 使用命令行进入该目录。 运行 \u0026ldquo;BeefBuild -new\u0026rdquo;，在该目录中初始化一个新的工作区和项目。 创建一个 \u0026ldquo;src/Program.bf\u0026rdquo; 文本文件，并将上述方框中的内容粘贴进去。 运行 \u0026ldquo;BeefBuild -run\u0026rdquo; 来编译并执行。 "},{"id":7,"href":"/BeefDoc/docs/BeefDoc/LanguageGuide/MemoryManagement/","title":"内存管理","section":"语言指南","content":" 内存管理 # 内存分配 # 内存分配可以放在堆栈、全局分配器或自定义分配器上。堆栈分配使用 \u0026ldquo;scope \u0026ldquo;关键字，它可以指定从当前作用域（即代码块）到整个方法作用域（甚至在循环中）的范围。\nstatic void Test(StreamReader fs)\r{\rlet strList = scope List\u0026lt;String\u0026gt;();\rfor (let line in fs.Lines)\r{\r/* 该字符串的范围是整个方法 */\rlet lineStr = scope:: String(line);\rstrList.Add(lineStr);\r}\rstrList.Sort();\r}\rstatic void Test(StreamReader fs)\r{\rSort:\r{\rlet strList = scope List\u0026lt;String\u0026gt;();\rfor (let line in fs.Lines)\r{\r/* 该字符串的范围是 \u0026#34;Sort\u0026#34; 范围 */\rlet lineStr = scope:Sort String(line);\rstrList.Add(lineStr);\r}\rstrList.Sort();\r}\r} 作用域分配会动态增加堆栈大小，因此必须确保有足够的堆栈空间用于给定的计算，就像递归方法必须确保递归深度不会耗尽堆栈一样。\n通过全局分配器进行的分配使用 \u0026ldquo;new \u0026ldquo;关键字。\nString AllocGlobalString(int len)\r{\rreturn new String(len);\r} 通过自定义分配器进行分配时，需要使用 \u0026ldquo;new \u0026ldquo;关键字并指定自定义分配器实例。\nString AllocCustomString(int len)\r{\rreturn new:customAllocator String(len);\r} 自定义分配器至少只能实现一个 Alloc 方法，但也可以添加一个 AllocTyped 方法，以添加特定类型的分配逻辑。内存通过 Free 方法释放。\nstruct ArenaAlloc\r{\rpublic void* Alloc(int size, int align)\r{\rreturn Internal.StdMalloc(size);\r}\rpublic void* AllocTyped(Type type, int size, int align)\r{\rvoid* data = Alloc(size, align);\rif (type.HasDestructor)\rMarkRequiresDeletion(data);\rreturn data;\r}\rpublic void Free(void* ptr)\r{\rInternal.StdFree(ptr);\r}\rpublic void MarkRequiresDeletion(void* obj)\r{\r/* TODO: 在分配器被弃置时调用此对象的析构函数 */\r}\r} 请注意，如果启用了实时泄漏检查，且自定义分配器使用了泄漏检查器尚未跟踪的内存，则分配器需要报告其内存，以便扫描对象引用。请参阅 corlib BumpAllocator，了解如何与泄漏检查器合作，尤其是 \u0026ldquo;GCMarkMembers \u0026ldquo;方法。\n自定义分配也可以通过 混合体进行分配，混合体甚至可以有条件地在堆栈上进行分配。例如，ScopedAlloc 混合元素将在堆栈上执行小规模分配，而在堆上执行大规模对象分配。\nstatic mixin ScopedAlloc(int size, int align)\r{\rvoid* data;\rif (size \u0026lt;= 128)\r{\rdata = scope:mixin [Align(align)] uint8[size]* { ? };\r}\relse\r{\rdata = new [Align(align)] uint8[size]* { ? };\rdefer:mixin delete data;\r}\rdata\r}\rvoid ReadString(int reserveLen)\r{\rString str = new:ScopedAlloc! String(reserveLen);\rdefer delete:null str;\rUseString(str);\r} 请注意在上述情况中使用了 delete:null。ScopedAlloc! 调用将释放实际分配的内存，但不会调用字符串析构函数。如果 UseString 向 str 追加了超出 reserveLen 的数据，就会发生堆分配，需要由字符串析构函数释放。删除:null 允许你在不请求释放任何内存的情况下执行销毁。\n许多 corlib 类（如 System.String 和 System.Collections.List）需要动态分配内存。按照惯例，这些类从全局分配器中分配内存，并通过虚拟方法重载（如 String.Alloc 和 String.Free）为内部分配支持自定义分配器。\n全局分配器 # 全局分配器按工作区选择。默认情况下，使用 CRT malloc/free 分配器，但也可以使用任何 C 风格的全局分配器，如 TCMalloc 或 JEMalloc。此外，Beef 还包含一个特殊的调试分配器，可实现实时泄漏检查和热编译等功能。\nBeef 分配器是 C 风格的，因为它们不可重新分配，也没有垃圾回收器。\n释放内存 # 作用域分配会在作用域结束时自动释放，但手动分配必须使用 \u0026ldquo;delete \u0026ldquo;关键字手动释放。与自定义分配器分配类似，delete 可以指定一个自定义分配器目标，用于从自定义分配器释放内存。\n追加分配 # 追加分配是一类特殊的分配，可以放在构造函数中，在分配拥有对象的内存时，可以手动要求分配额外的内存。这在 corlib 中用于接受 \u0026ldquo;size \u0026ldquo;参数的字符串等。\nclass FloatArray\r{\rint mLength;\rfloat* mPtr;\r[AllowAppend]\rpublic this(int length)\r{\rlet ptr = append float[length]*; mPtr = ptr;\rmLength = length;\r}\r}\r/* 追加分配保证紧随对象自身内存之后（与对齐方式有关）。我们可以利用这一知识来计算数组的存储位置，而不是将其存储在内部 */\rclass FloatArray\r{\rint mLength;\r[AllowAppend]\rpublic this(int length)\r{\rlet ptr = append float[length]*;\rmLength = length;\r}\rpublic float* Ptr\r{\rget\r{\rreturn (float*)(\u0026amp;mLength + 1);\r}\r}\r} 在内部，追加分配是通过创建一个大小计算函数来实现的，该函数会在分配之前被调用。编译器会尝试在调用点对该函数和相关参数执行常量评估，结果可能是一个固定大小的分配，而不是一个动态大小的分配，这样就去除了额外的调用，对于某些堆栈分配来说也会更快。\n追加分配的内存无需显式释放，但仍可通过 delete:append obj 语句调用对象析构函数。\n装箱 # 所有值类型（基元、结构体、元组、指针、枚举）都可以 \u0026ldquo;装箱 \u0026ldquo;到对象中，这对于动态类型处理和接口分派非常有用。所有基元类型都有用于装箱的库定义结构封装器（即：int32 基元会被 System.Int32 封装）。装箱是一种分配操作，它隐式地发生在投向 System.Object 时的临时堆栈分配中，但也可以显式地指定长期装箱和更长时间的堆栈分配。当值类型被装箱时，会静态生成一个特殊的 \u0026ldquo;装箱类型\u0026rdquo;，该类型会包裹给定的值类型。这会导致代码臃肿，这就是为什么这些盒式类型只在每个值类型需要时才生成。\n// 格式调用依靠装箱来处理输入类型\rConsole.WriteLine(\u0026#34;a + b = {}\u0026#34;, a + b);\rObject a = 1.2f; // 堆栈上对当前作用域进行隐式装箱。\rObject b = scope box:: 2.3f; // 将堆栈中的对象显式地框定到方法作用域中\rObject c = new:allok box 4.5f; // 通过自定义分配器 \u0026#34;allok \u0026#34;显式装箱 变体 # 变体类型 System.Variant 是装箱的另一种选择。变体不是对象类型，因此不能执行动态接口分派，但变体的优点是可以存储小数据类型而无需分配，也不会导致装箱代码臃肿。变体可以通过 Variant.GetBoxed 转换为堆分配的盒式对象，但如果编译器没有为存储的值类型按需生成盒式类型，则转换会失败。可以通过 反射选项特别要求生成盒式类型。\n"},{"id":8,"href":"/BeefDoc/docs/BeefDoc/LanguageGuide/","title":"语言指南","section":"目录","content":" 语言指南 # 语言指南概述 # Beef 生态系统由语言、核心库和 Beef 工具（包括集成开发环境）组成。尽管这三个部分紧密协作，但本部分文档仅专门介绍语言。\n"},{"id":9,"href":"/BeefDoc/posts/MemoryManagement/","title":"笔记 | 内存管理","section":"笔记","content":" 笔记 | 内存管理 # "}]